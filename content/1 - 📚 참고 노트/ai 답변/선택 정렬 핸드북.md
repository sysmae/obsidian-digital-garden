---
publish:  true
---

<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" class="logo" width="120"/>

# 선택 정렬 핸드북

## 주요 개요

**선택 정렬(Selection Sort)**은 배열에서 가장 작은(또는 가장 큰) 요소를 반복적으로 찾아 배열의 앞쪽에 위치시키는 단순 비교 기반 정렬 알고리즘이다.

- 시간 복잡도: 최악·평균·최선 모두 O(n²)
- 공간 복잡도: O(1) (제자리 정렬)
- 안정성: 불안정 정렬


## 1. 설계 배경 및 동기

1) **단순성**
    - 개념과 구현이 직관적이어서 정렬 알고리즘 학습용으로 널리 사용됨.
2) **제자리(in-place) 정렬**
    - 추가 메모리 없이 입력 배열만을 조작하여 정렬 가능.
3) **교환 횟수 최소화**
    - 교환(swap) 연산이 적어, 교환 비용이 큰 환경에서 유리.

## 2. 알고리즘 구조

1) **초기 상태**
    - 정렬 구간: 배열 인덱스 0부터 n–1 전체
2) **반복 단계** (i = 0 … n–2)
a. 미정렬 구간[i…n–1]에서 최소값(min_idx) 탐색
b. 위치 i와 min_idx의 값을 교환
c. 정렬 구간 끝 위치(i) 확장
3) **종료 조건**
    - i가 n–2에 도달하면 마지막 두 원소도 정렬되어 알고리즘 종료

## 3. 상세 동작 흐름 (3단계 더 세분화)

1) 첫 번째 패스 (i = 0)
1-1) 전체 배열에서 최소값 찾기
1-2) 최소값이 위치한 인덱스와 0번 인덱스 교환
1-3) 배열 확정, 정렬 구간 → 배열[1…n–1]
2) 두 번째 패스 (i = 1)
2-1) 배열[1…n–1]에서 최소값 찾기
2-2) 해당 최소값 인덱스와 1번 인덱스 교환
2-3) 배열[0…1] 확정, 정렬 구간 → 배열[2…n–1]
3) k번째 패스 (i = k–1)
3-1) 배열[k–1…n–1] 내 최소값 탐색
3-2) 위치 교환 및 정렬 구간 확장
4) 최종 패스 (i = n–2)
4-1) 배열[n–2…n–1] 내 두 값 비교 후 교환
4-2) 전체 배열 완전 정렬

## 4. 구현 예제 (파이썬)

```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        min_idx = i
        # 최소값 인덱스 찾기
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        # 값 교환
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

# 예시
data = [64, 25, 12, 22, 11]
print(selection_sort(data))
# 출력: [11, 12, 22, 25, 64]
```


## 5. 장단점 및 활용

| 항목 | 장점 | 단점 |
| :-- | :-- | :-- |
| 시간 | 교환 횟수 고정적(O(n)) | 비교 횟수 많음(O(n²)), 비효율적 |
| 메모리 | 추가 공간 없이 제자리 정렬 가능 | 안정 정렬 아님 |
| 구현 난이도 | 매우 간단 | 대규모 데이터 처리에 부적합 |
| 활용 예시 | 작은 배열, 교환 비용이 큰 시스템, 교육용 | 빅데이터 정렬, 실시간 정렬 필요 시 부적합 |

## 6. 사용법 가이드

1. **배열 크기 확인**
    - n이 수백 이상인 경우 성능 저하 고려
2. **데이터 특성 평가**
    - 이미 거의 정렬된 배열에는 다른 알고리즘(삽입 정렬 등) 우선
3. **메모리 제약 환경**
    - 메모리 여유 없을 때 선택 정렬 고려
4. **교환 비용**
    - 교환 오버헤드가 크면 비교 위주의 선택 정렬 유리

## 7. 결론 및 추천

선택 정렬은 단순하고 메모리 효율적인 제자리 정렬이지만, O(n²) [[5 - 💎 영구 노트/시간 복잡도]]로 인해 대규모 실무용으로는 부적합하다. **소규모 배열** 또는 **교환 비용이 큰 환경**에서 학습 및 특정 상황용으로 사용할 것을 권장한다.

