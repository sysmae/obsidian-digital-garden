---
publish: true
---
#2025-08-08 00:34

Tags:

# SOLID μ›μΉ™ ν•Έλ“λ¶

### 1. λ§λ“¤μ–΄μ§„ μ΄μ : κ²¬κ³ ν•κ³  μ μ—°ν• μ„¤κ³„λ¥Ό μ„ν• 5κ°€μ§€ κΈ°λ‘¥

μ†ν”„νΈμ›¨μ–΄ κ°λ°μ μ—­μ‚¬λ” 'λ³€κ²½'κ³Όμ μ‹Έμ›€μ΄μ—μµλ‹λ‹¤. μƒλ΅μ΄ κΈ°λ¥ μ¶”κ°€, λΉ„μ¦λ‹μ¤ λ΅μ§ λ³€κ²½, κΈ°μ μ λ°μ „ λ“± μ†ν”„νΈμ›¨μ–΄λ” λμ„μ—†μ΄ λ³€ν™”λ¥Ό μ”κµ¬λ°›μµλ‹λ‹¤. μ΄ κ³Όμ •μ—μ„ μλ»λ μ„¤κ³„λ” μ½”λ“λ¥Ό λ‹¨λ‹¨ν•κ² κµ³μ–΄λ²„λ¦¬κ²(**κ²½μ§μ„±**), μ‘μ€ μμ •μ΄ μμƒμΉ λ»ν• μ¤λ¥λ¥Ό λ‚³κ²(**μ·¨μ•½μ„±**), λ‹¤λ¥Έ κ³³μ—μ„ μ¬μ‚¬μ©ν•κΈ° μ–΄λ µκ²(**λ¶€λ™μ„±**) λ§λ“­λ‹λ‹¤.

μ΄λ¬ν• 'μ©μ–΄κ°€λ” μ½”λ“'μ λ¬Έμ λ¥Ό ν•΄κ²°ν•κΈ° μ„ν•΄, λ΅λ²„νΈ C. λ§ν‹΄μ€ κ°μ²΄ μ§€ν–¥ ν”„λ΅κ·Έλλ° λ° μ„¤κ³„μ ν•µμ‹¬ μ›μΉ™ λ‹¤μ„― κ°€μ§€λ¥Ό μ •λ¦¬ν•μ—¬ **SOLID**λΌλ” μ΄λ¦„μΌλ΅ μ„Έμƒμ— λ‚΄λ†“μ•μµλ‹λ‹¤. SOLIDλ” λ‹¨μν μ½”λ“λ¥Ό μμκ² λ§λ“λ” κΈ°λ²•μ΄ μ•„λ‹™λ‹λ‹¤. **λ³€ν™”μ— μ μ—°ν•κ² λ€μ²ν•κ³ , μ μ§€λ³΄μκ°€ μ©μ΄ν•λ©°, μ΄ν•΄ν•κΈ° μ‰¬μ΄ μ†ν”„νΈμ›¨μ–΄λ¥Ό λ§λ“¤κΈ° μ„ν• μ„¤κ³„ μ² ν•™μ΄μ νΌνΌν• κΈ°λ‘¥**μ…λ‹λ‹¤.

μ΄ λ‹¤μ„― κ°€μ§€ μ›μΉ™λ“¤μ€ μ„λ΅ μ κΈ°μ μΌλ΅ μ‘μ©ν•μ—¬, μ‹μ¤ν…μ **κ²°ν•©λ„(Coupling)λ” λ‚®μ¶”κ³  μ‘μ§‘λ„(Cohesion)λ” λ†’μ—¬** κ±΄κ°•ν• μ†ν”„νΈμ›¨μ–΄ κµ¬μ΅°λ¥Ό μ μ§€ν•λ„λ΅ λ•μµλ‹λ‹¤.

---

### 2. SOLID: λ‹¤μ„― κ°€μ§€ μ›μΉ™ μƒμ„Έ νƒκµ¬

SOLIDλ” λ‹¤μ λ‹¤μ„― κ°€μ§€ μ›μΉ™μ μ• κΈ€μλ¥Ό λ”΄ μ΄λ¦„μ…λ‹λ‹¤.

- **S**: λ‹¨μΌ μ±…μ„ μ›μΉ™ (Single Responsibility Principle)1
    
- **O**: κ°λ°©-νμ‡„ μ›μΉ™ (Open-Closed Principle)2
    
- **L**: λ¦¬μ¤μ½”ν”„ μΉν™ μ›μΉ™ (Liskov Substitution Principle)3
    
- **I**: μΈν„°νμ΄μ¤ λ¶„λ¦¬ μ›μΉ™ (Interface Segregation Principle)4
    
- **D**: μμ΅΄κ΄€κ³„ μ—­μ „ μ›μΉ™ (Dependency Inversion Principle)
    

#### S: λ‹¨μΌ μ±…μ„ μ›μΉ™ (SRP)

> **"ν•λ‚μ ν΄λμ¤λ” λ‹¨ ν•λ‚μ λ³€κ²½ μ΄μ λ§μ„ κ°€μ Έμ•Ό ν•λ‹¤."**

μ΄λ” ν΄λμ¤κ°€ μ±…μ„μ Έμ•Ό ν•  **μ•΅ν„°(Actor) λλ” λΉ„μ¦λ‹μ¤ κ΄€μ‹¬μ‚¬κ°€ λ‹¨ ν•λ‚**μ—¬μ•Ό ν•¨μ„ μλ―Έν•©λ‹λ‹¤. μ—¬λ¬ μ±…μ„μ„ κ°€μ§„ ν΄λμ¤λ” κ° μ±…μ„μ΄ λ³€κ²½λ  λ•λ§λ‹¤ μμ •λμ–΄μ•Ό ν•λ―€λ΅ λ¶μ•μ •ν•΄μ§‘λ‹λ‹¤.

- **ν•µμ‹¬**: μ±…μ„μ„ λ¶„λ¦¬ν•μ—¬ λ³€κ²½μ νκΈ‰ ν¨κ³Όλ¥Ό μµμ†ν™”.
    
- **μμ‹**: μ§μ›μ κΈ‰μ—¬ κ³„μ‚°, κ·Όλ¬΄ μ‹κ°„ λ³΄κ³ , λ°μ΄ν„°λ² μ΄μ¤ μ €μ¥ κΈ°λ¥μ΄ ν• ν΄λμ¤μ— μλ‹¤λ©΄, μ΄λ¥Ό `PayCalculator`, `HourReporter`, `EmployeeRepository`μ²λΌ κ°κ°μ μ±…μ„μ— λ”°λΌ λ³„λ„μ ν΄λμ¤λ΅ λ¶„λ¦¬.
    

#### O: κ°λ°©-νμ‡„ μ›μΉ™ (OCP)

> **"μ†ν”„νΈμ›¨μ–΄ κ°μ²΄(ν΄λμ¤, λ¨λ“, ν•¨μ λ“±)λ” ν™•μ¥μ— λ€ν•΄μ„λ” μ—΄λ ¤ μμ–΄μ•Ό ν•μ§€λ§, λ³€κ²½μ— λ€ν•΄μ„λ” λ‹«ν€ μμ–΄μ•Ό ν•λ‹¤."**

μƒλ΅μ΄ κΈ°λ¥μ„ μ¶”κ°€ν•  λ• κΈ°μ΅΄ μ½”λ“λ¥Ό μμ •ν•λ” κ²ƒμ΄ μ•„λ‹λΌ, μƒλ΅μ΄ μ½”λ“λ¥Ό μ¶”κ°€ν•μ—¬ κΈ°λ¥μ„ ν™•μ¥ν•΄μ•Ό ν•λ‹¤λ” μ›μΉ™μ…λ‹λ‹¤. μ΄λ” **μ¶”μƒν™”(μΈν„°νμ΄μ¤, μ¶”μƒ ν΄λμ¤)μ™€ λ‹¤ν•μ„±**μ„ ν†µν•΄ λ‹¬μ„±λ©λ‹λ‹¤.

- **ν•µμ‹¬**: κΈ°μ΅΄μ μ•μ •μ μΈ μ½”λ“λ” κ±΄λ“λ¦¬μ§€ μ•κ³ , μƒλ΅μ΄ κΈ°λ¥μ„ μ‰½κ² μ¶”κ°€ν•  μ μλ” κµ¬μ΅°λ¥Ό λ§λ“¦.
    
- **λΉ„μ **: μ¤λ§νΈν°. μƒλ΅μ΄ μ•±(κΈ°λ¥ ν™•μ¥)μ„ μ„¤μΉν•  μ μμ§€λ§, κ·Έλ΅ μΈν•΄ μ¤λ§νΈν°μ μ΄μμ²΄μ (κΈ°μ΅΄ μ½”λ“)κ°€ λ³€κ²½λμ§€λ” μ•μ.
    

**OCP μ„λ° μ‚¬λ΅€ (Bad Case)**

Java

```
// μƒλ΅μ΄ κ²°μ  μλ‹¨μ΄ μ¶”κ°€λ  λ•λ§λ‹¤ μ΄ ν΄λμ¤λ¥Ό μμ •ν•΄μ•Ό ν•¨ (λ³€κ²½μ— μ—΄λ ¤ μμ)
public class PaymentProcessor {
    public void process(String paymentType) {
        if (paymentType.equals("creditCard")) {
            // μ‹ μ©μΉ΄λ“ κ²°μ  λ΅μ§
        } else if (paymentType.equals("paypal")) {
            // νμ΄ν” κ²°μ  λ΅μ§
        }
        // μƒλ΅μ΄ κ²°μ  μλ‹¨ μ¶”κ°€ μ‹ μ—¬κΈ°μ— else ifκ°€ κ³„μ† λμ–΄λ‚¨
    }
}
```

**OCP μ μ© μ‚¬λ΅€ (Good Case)**

Java

```
// 1. κ²°μ  μΈν„°νμ΄μ¤ μ •μ (μ¶”μƒν™”)
interface PaymentMethod {
    void processPayment();
}

// 2. κµ¬μ²΄μ μΈ κ²°μ  λ°©λ²• κµ¬ν„
class CreditCardPayment implements PaymentMethod {
    public void processPayment() { /* μ‹ μ©μΉ΄λ“ κ²°μ  λ΅μ§ */ }
}

class PaypalPayment implements PaymentMethod {
    public void processPayment() { /* νμ΄ν” κ²°μ  λ΅μ§ */ }
}

// μƒλ΅μ΄ κ²°μ  μλ‹¨μ΄ μƒκ²¨λ„ κΈ°μ΅΄ μ½”λ“λ” μμ •ν•  ν•„μ”κ°€ μ—†μ
class BankTransferPayment implements PaymentMethod {
    public void processPayment() { /* κ³„μΆ μ΄μ²΄ λ΅μ§ */ }
}

// 3. κ²°μ  μ²λ¦¬κΈ°λ” μΈν„°νμ΄μ¤μ—λ§ μμ΅΄
public class PaymentProcessor {
    public void process(PaymentMethod paymentMethod) {
        paymentMethod.processPayment(); // μ–΄λ–¤ κ²°μ  λ°©μ‹μ΄λ“  λ™μΌν•κ² νΈμ¶
    }
}
```

#### L: λ¦¬μ¤μ½”ν”„ μΉν™ μ›μΉ™ (LSP)

> **"ν•μ„ νƒ€μ…μ€ μ–Έμ λ‚ μμ‹ μ κΈ°λ° νƒ€μ…(μƒμ„ νƒ€μ…)μΌλ΅ κµμ²΄λ  μ μμ–΄μ•Ό ν•λ‹¤."**

μ΄λ” **μƒμ† κ΄€κ³„μ μΌκ΄€μ„±μ„ λ³΄μ¥**ν•λ” μ›μΉ™μ…λ‹λ‹¤. μμ‹ ν΄λμ¤λ” λ¶€λ¨ ν΄λμ¤μ μ—­ν• μ„ μ¨μ „ν μν–‰ν•  μ μμ–΄μ•Ό ν•λ©°, μμ‹ ν΄λμ¤λ¥Ό μ‚¬μ©ν•λ‹¤κ³  ν•΄μ„ ν”„λ΅κ·Έλ¨μ λ™μ‘μ΄ μκΈ°μΉ μ•κ² λ³€κ²½λμ–΄μ„λ” μ• λ©λ‹λ‹¤.

- **ν•µμ‹¬**: μƒμ†μ€ 'IS-A' κ΄€κ³„λ¥Ό λ„μ–΄μ„, 'ν–‰λ™μ μΌκ΄€μ„±'κΉμ§€ λ³΄μ¥ν•΄μ•Ό ν•¨.
    
- **μ λ…ν• μμ‹**: 'μ •μ‚¬κ°ν•-μ§μ‚¬κ°ν•' λ¬Έμ . μ •μ‚¬κ°ν•(`Square`)μ€ μ§μ‚¬κ°ν•(`Rectangle`)μ ν• μΆ…λ¥μ΄λ―€λ΅ μƒμ† κ΄€κ³„(`Square extends Rectangle`)κ°€ μ„±λ¦½ν•λ” κ²ƒμ²λΌ λ³΄μ…λ‹λ‹¤. ν•μ§€λ§ μ§μ‚¬κ°ν•μ `setWidth()`μ™€ `setHeight()`κ°€ λ…λ¦½μ μΌλ΅ λ™μ‘ν•΄μ•Ό ν•λ‹¤λ” κ·μΉ™μ„ μ •μ‚¬κ°ν•μ€ μ„λ°ν•©λ‹λ‹¤(λ„λΉ„λ¥Ό λ°”κΎΈλ©΄ λ†’μ΄λ„ λ°”λ€μ–΄μ•Ό ν•λ―€λ΅). λ”°λΌμ„ `Square` κ°μ²΄λ” `Rectangle` κ°μ²΄λ¥Ό μ™„λ²½ν λ€μ²΄ν•  μ μ—†μΌλ―€λ΅ LSPλ¥Ό μ„λ°ν•©λ‹λ‹¤.
    

**LSP μ„λ° μ‚¬λ΅€ (Bad Case)**

Java

```
class Bird {
    public void fly() { /* λ‚λ” λ΅μ§ */ }
}

class Ostrich extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("νƒ€μ΅°λ” λ‚  μ μ—†μµλ‹λ‹¤."); // λ¶€λ¨μ ν–‰λ™μ„ μν–‰ν•  μ μ—†μ
    }
}

public class BirdWatcher {
    public void watch(Bird bird) {
        bird.fly(); // Ostrich κ°μ²΄κ°€ λ“¤μ–΄μ¤λ©΄ μ—¬κΈ°μ„ μμ™Έ λ°μƒ
    }
}
```

#### I: μΈν„°νμ΄μ¤ λ¶„λ¦¬ μ›μΉ™ (ISP)

> **"ν΄λΌμ΄μ–ΈνΈλ” μμ‹ μ΄ μ‚¬μ©ν•μ§€ μ•λ” λ©”μ„λ“μ— μμ΅΄ν•λ„λ΅ κ°•μ”λμ–΄μ„λ” μ• λλ‹¤."**

ν•λ‚μ κ±°λ€ν•(fat) μΈν„°νμ΄μ¤λ³΄λ‹¤λ”, μ—¬λ¬ κ°μ κµ¬μ²΄μ μΈ(client-specific) μΈν„°νμ΄μ¤λ΅ λ¶„λ¦¬ν•λ” κ²ƒμ΄ μΆ‹λ‹¤λ” μ›μΉ™μ…λ‹λ‹¤. μ΄λ” SRPκ°€ ν΄λμ¤μ— μ μ©λλ” κ²ƒκ³Ό μ μ‚¬ν•κ², μΈν„°νμ΄μ¤μ— μ μ©λλ” λ²„μ „μ΄λΌκ³  λ³Ό μ μμµλ‹λ‹¤.

- **ν•µμ‹¬**: ν΄λΌμ΄μ–ΈνΈμ λ©μ μ— λ§κ² μΈν„°νμ΄μ¤λ¥Ό μ‘κ² μ μ§€ν•μ—¬, λ¶ν•„μ”ν• μμ΅΄μ„±μ„ μ κ±°.
    
- **λΉ„μ **: λ³µν•©κΈ°. λ‚λ” 'μ¤μΊ”' κΈ°λ¥λ§ ν•„μ”ν•λ°, 'μΈμ‡„', 'ν©μ¤' κΈ°λ¥κΉμ§€ λ¨λ‘ ν¬ν•¨λ κ±°λ€ν• μΈν„°νμ΄μ¤λ¥Ό λ‹¤λ£° ν•„μ”λ” μ—†μ. 'μ¤μΊλ„ μΈν„°νμ΄μ¤'λ§ μ‚¬μ©ν•λ” κ²ƒμ΄ λ” ν¨μ¨μ .
    

**ISP μ„λ° μ‚¬λ΅€ (Bad Case)**

Java

```
// κ°λ°μμ™€ μ‹λ‹Ή μ£Όλ°©μ¥μ€ λ¨λ‘ 'λ…Έλ™μ'μ§€λ§, ν•„μ”ν• κΈ°λ¥μ΄ λ‹¤λ¦„
interface Worker {
    void work();
    void eat();
}

class Developer implements Worker {
    public void work() { /* μ½”λ”©ν•κΈ° */ }
    public void eat() { /* μ μ‹¬ λ¨ΉκΈ° */ }
}

class Chef implements Worker {
    public void work() { /* μ”λ¦¬ν•κΈ° */ }
    public void eat() { /* μ €λ… λ¨ΉκΈ° */ }
}

// μΌλ§ ν•λ” λ΅λ΄‡μ€ eat() κΈ°λ¥μ΄ ν•„μ” μ—†μ§€λ§, κ°•μ λ΅ κµ¬ν„ν•΄μ•Ό ν•¨
class Robot implements Worker {
    public void work() { /* μ΅°λ¦½ν•κΈ° */ }
    public void eat() { /* μ•„λ¬΄κ²ƒλ„ μ• ν•¨ - λ¶ν•„μ”ν• κµ¬ν„ */ }
}
```

**ISP μ μ© μ‚¬λ΅€ (Good Case)**

Java

```
// μ±…μ„μ„ κΈ°μ¤€μΌλ΅ μΈν„°νμ΄μ¤λ¥Ό λ¶„λ¦¬
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

// ν•„μ”ν• μΈν„°νμ΄μ¤λ§ κµ¬ν„
class Developer implements Workable, Eatable { /* ... */ }
class Chef implements Workable, Eatable { /* ... */ }
class Robot implements Workable { /* ... */ } // μ΄μ  eat()μ„ κ°•μ λ΅ κµ¬ν„ν•  ν•„μ” μ—†μ
```

#### D: μμ΅΄κ΄€κ³„ μ—­μ „ μ›μΉ™ (DIP)

> 1. μƒμ„ μμ¤€ λ¨λ“μ€ ν•μ„ μμ¤€ λ¨λ“μ— μμ΅΄ν•΄μ„λ” μ• λλ‹¤. λ‘ λ¨λ‘ μ¶”μƒν™”μ— μμ΅΄ν•΄μ•Ό ν•λ‹¤.
> 
> 2. μ¶”μƒν™”λ” μ„Έλ¶€ μ‚¬ν•­μ— μμ΅΄ν•΄μ„λ” μ• λλ‹¤. μ„Έλ¶€ μ‚¬ν•­μ΄ μ¶”μƒν™”μ— μμ΅΄ν•΄μ•Ό ν•λ‹¤.

μ΄λ” **'κµ¬μ²΄μ μΈ κµ¬ν„'μ΄ μ•„λ‹ 'μ¶”μƒμ μΈ μΈν„°νμ΄μ¤'μ— μμ΅΄**ν•λΌλ” μ›μΉ™μ…λ‹λ‹¤. μƒμ„ μμ¤€μ λΉ„μ¦λ‹μ¤ λ΅μ§(μƒμ„ λ¨λ“)μ΄ ν•μ„ μμ¤€μ κµ¬μ²΄μ μΈ κµ¬ν„(ν•μ„ λ¨λ“, μ: νΉμ • λ°μ΄ν„°λ² μ΄μ¤ λΌμ΄λΈλ¬λ¦¬)μ— μ§μ ‘ μμ΅΄ν•λ©΄, ν•μ„ λ¨λ“μ΄ λ³€κ²½λ  λ• μƒμ„ λ¨λ“λ„ ν•¨κ» λ³€κ²½λμ–΄μ•Ό ν•©λ‹λ‹¤. μ΄λ¥Ό λ§‰κΈ° μ„ν•΄ λ‘ μ‚¬μ΄μ— 'μ¶”μƒν™”(μΈν„°νμ΄μ¤)' κ³„μΈµμ„ λ‘λ” κ²ƒμ…λ‹λ‹¤.

- **ν•µμ‹¬**: μμ΅΄μ„±μ λ°©ν–¥μ„ 'μ—­μ „'μ‹μΌ, κµ¬μ²΄μ μΈ κ²ƒ λ€μ‹  μ¶”μƒμ μΈ κ²ƒμ— μμ΅΄ν•κ² λ§λ“¤μ–΄ μ μ—°μ„±μ„ ν™•λ³΄.
    
- **λΉ„μ **: μ»΄ν“¨ν„°μ™€ ν‚¤λ³΄λ“. μ»΄ν“¨ν„°(μƒμ„ λ¨λ“)λ” 'USB ν¬νΈ'λΌλ” ν‘μ¤€ μΈν„°νμ΄μ¤(μ¶”μƒν™”)μ— μμ΅΄ν•©λ‹λ‹¤. λ”°λΌμ„ 'Aμ‚¬ ν‚¤λ³΄λ“', 'Bμ‚¬ ν‚¤λ³΄λ“'(ν•μ„ λ¨λ“, μ„Έλ¶€ μ‚¬ν•­) μ–΄λ–¤ κ²ƒμ„ κ°€μ Έμ™€λ„ USB ν¬νΈ κ·κ²©λ§ λ§μΌλ©΄ μ»΄ν“¨ν„°λ” λ¬Έμ μ—†μ΄ μ‘λ™ν•©λ‹λ‹¤. μ»΄ν“¨ν„°κ°€ νΉμ • 'Aμ‚¬ ν‚¤λ³΄λ“'μ λ‚΄λ¶€ νλ΅μ— μ§μ ‘ μμ΅΄ν•μ§€ μ•λ” κ²ƒκ³Ό κ°™μµλ‹λ‹¤.
    

**DIP μ„λ° μ‚¬λ΅€ (Bad Case)**

Java

```
// μƒμ„ λ¨λ“μΈ Carκ°€ ν•μ„ λ¨λ“μΈ NormalTireμ— μ§μ ‘ μμ΅΄
class NormalTire {
    public String getTireType() { return "μΌλ° νƒ€μ΄μ–΄"; }
}

class Car {
    private NormalTire tire; // κµ¬μ²΄μ μΈ ν΄λμ¤μ— μμ΅΄

    public Car() {
        this.tire = new NormalTire(); // μ§μ ‘ μƒμ„±
    }

    public void printTireType() {
        System.out.println(tire.getTireType());
    }
}
```

**DIP μ μ© μ‚¬λ΅€ (Good Case)**

Java

```
// 1. Tire μΈν„°νμ΄μ¤ μ •μ (μ¶”μƒν™”)
interface Tire {
    String getTireType();
}

// 2. μ„Έλ¶€ μ‚¬ν•­μ΄ μ¶”μƒν™”μ— μμ΅΄
class NormalTire implements Tire {
    public String getTireType() { return "μΌλ° νƒ€μ΄μ–΄"; }
}

class SnowTire implements Tire {
    public String getTireType() { return "μ¤λ…Έμ° νƒ€μ΄μ–΄"; }
}

// 3. μƒμ„ λ¨λ“μ΄ μ¶”μƒν™”μ— μμ΅΄
class Car {
    private Tire tire; // μ¶”μƒ μΈν„°νμ΄μ¤μ— μμ΅΄

    // μ™Έλ¶€μ—μ„ μμ΅΄μ„±μ„ μ£Όμ…λ°›μ (Dependency Injection)
    public Car(Tire tire) {
        this.tire = tire;
    }

    public void printTireType() {
        System.out.println(tire.getTireType());
    }
}
```

---

### 3. μ‹¬ν™”: SOLIDλ” ν•¨κ»ν•  λ• λ” κ°•ν•λ‹¤

SOLIDμ λ‹¤μ„― κ°€μ§€ μ›μΉ™μ€ λ…λ¦½μ μΌλ΅λ„ μλ―Έκ°€ μμ§€λ§, ν•¨κ» μ μ©λ  λ• μ§„μ •ν• μ‹λ„μ§€λ¥Ό λ°νν•©λ‹λ‹¤.

- **OCP**λ¥Ό μ§€ν‚¤κΈ° μ„ν•΄μ„λ” **DIP**μ™€ **LSP**κ°€ κΈ°λ°μ΄ λμ–΄μ•Ό ν•©λ‹λ‹¤. λ³€ν™”μ— λ‹«ν€ μμΌλ ¤λ©΄ κµ¬μ²΄μ μΈ κµ¬ν„μ΄ μ•„λ‹ μ¶”μƒν™”μ— μμ΅΄ν•΄μ•Ό ν•κ³ (DIP), ν™•μ¥μ„ μ„ν•΄ λ§λ“¤μ–΄μ§„ ν•μ„ νƒ€μ…μ΄ μƒμ„ νƒ€μ…μ„ λ¬Έμ μ—†μ΄ λ€μ²΄ν•  μ μμ–΄μ•Ό ν•κΈ° λ•λ¬Έμ…λ‹λ‹¤(LSP).
    
- **ISP**μ™€ **SRP**λ” ν΄λμ¤μ™€ μΈν„°νμ΄μ¤μ ν¬κΈ°λ¥Ό μ μ ν•κ² μ μ§€ν•μ—¬ μ‹μ¤ν…μ λ³µμ΅λ„λ¥Ό λ‚®μ¶”κ³ , κ²°κ³Όμ μΌλ΅ λ‹¤λ¥Έ μ›μΉ™λ“¤μ„ μ μ©ν•κΈ° μ‰½κ² λ§λ“λ” ν† λ€λ¥Ό μ κ³µν•©λ‹λ‹¤.
    

SOLIDλ” κ·μΉ™μ΄ μ•„λ‹ μ›μΉ™μ…λ‹λ‹¤. λ¨λ“  μƒν™©μ— λ§Ήλ©μ μΌλ΅ μ μ©ν•κΈ°λ³΄λ‹¤λ”, ν”„λ΅μ νΈμ νΉμ„±κ³Ό λ³€ν™”μ κ°€λ¥μ„±μ„ κ³ λ ¤ν•μ—¬ μ μ—°ν•κ² μ‚¬μ©ν•λ” μ§€νκ°€ ν•„μ”ν•©λ‹λ‹¤. μ΄ μ›μΉ™λ“¤μ„ λ‚μΉ¨λ° μ‚Όμ•„ μ½”λ“λ¥Ό μ‘μ„±ν•λ‹¤λ©΄, μ‹κ°„μ΄ μ§€λ‚λ„ ν”λ“¤λ¦¬μ§€ μ•λ” κ²¬κ³ ν• μ†ν”„νΈμ›¨μ–΄λ¥Ό κµ¬μ¶•ν•  μ μμ„ κ²ƒμ…λ‹λ‹¤.

μ΄ μ›μΉ™λ“¤ μ¤‘μ—μ„ νΉν λ” μμ„Έν• μ„¤λ…μ΄λ‚ λ‹¤λ¥Έ μμ‹κ°€ κ¶κΈν• λ¶€λ¶„μ΄ μμΌμ‹ κ°€μ”?

### **SOLID μ›μΉ™ ν•Έλ“λ¶**

#### **1. νƒ„μƒ λ°°κ²½: μ™ SOLIDμΈκ°€?**

μ†ν”„νΈμ›¨μ–΄ κ°λ°μ μ—­μ‚¬λ” 'λ³€κ²½'κ³Όμ μ‹Έμ›€. λ΅λ²„νΈ C. λ§ν‹΄(Robert C. Martin, "Uncle Bob")μ€ μ‹κ°„μ΄ μ§€λ‚λ„ μ μ§€λ³΄μν•κΈ° μ‰½κ³ , μ μ—°ν•λ©°, μ΄ν•΄ν•κΈ° μ‰¬μ΄ μ†ν”„νΈμ›¨μ–΄λ¥Ό λ§λ“¤κΈ° μ„ν• 5κ°€μ§€ κ°μ²΄ μ§€ν–¥ μ„¤κ³„ μ›μΉ™μ„ μ •λ¦¬. μ΄κ²ƒμ΄ λ°”λ΅ **SOLID**.

μ΄ μ›μΉ™λ“¤μ€ νΉμ • κΈ°λ¥μ κµ¬ν„ λ°©λ²•μ΄ μ•„λ‹, **'λ³€κ²½'μ— μ–΄λ–»κ² λ€μ‘ν•  κ²ƒμΈκ°€**μ— λ€ν• μ§€μΉ¨. μ μ§€μ–΄μ§„ κ±΄λ¬Όμ²λΌ, μΌλ¶€λ¥Ό μλ¦¬ν•κ±°λ‚ ν™•μ¥ν•  λ• μ „μ²΄ κµ¬μ΅°κ°€ ν”λ“¤λ¦¬μ§€ μ•κ² ν•λ” μ„¤κ³„ μ² ν•™.

#### **2. S: λ‹¨μΌ μ±…μ„ μ›μΉ™ (Single Responsibility Principle, SRP)**

> "ν΄λμ¤λ” λ‹¨ ν•λ‚μ λ³€κ²½ μ΄μ λ§μ„ κ°€μ Έμ•Ό ν•λ‹¤."

- **ν•µμ‹¬ κ°λ…:** ν•λ‚μ ν΄λμ¤λ” ν•λ‚μ κΈ°λ¥ λλ” μ±…μ„λ§ λ‹΄λ‹Ή. μ—¬λ¬ μ±…μ„μ„ ν• ν΄λμ¤μ— λ°μ•„λ„£μΌλ©΄, κ΄€λ ¨ μ—†λ” κΈ°λ¥μ λ³€κ²½μ΄ λ‹¤λ¥Έ κΈ°λ¥μ— μν–¥μ„ λ―ΈμΉλ” 'λ‚λΉ„ ν¨κ³Ό'λ¥Ό μ λ°.
    
- **λ§λ“¤μ–΄μ§„ μ΄μ :** νΉμ • ν΄λμ¤κ°€ λ„λ¬΄ λ§μ€ μ—­ν• μ„ μν–‰ν•λ” 'λ§λ¥ ν΄λμ¤(God Class)'κ°€ λλ” κ²ƒμ„ λ°©μ§€. μ½”λ“κ°€ λΉ„λ€ν•΄μ§€κ³  λ³µμ΅ν•΄μ§€λ©΄ μμ •κ³Ό ν…μ¤νΈκ°€ κ·Ήλ„λ΅ μ–΄λ ¤μ›μ§€κΈ° λ•λ¬Έ.
    
- **λΉ„μ :** μ¤μ„μ¤ κµ°μ© μΉΌμ€ λ‹¤μ¬λ‹¤λ¥ν•μ§€λ§, μ „λ¬Έ μ”λ¦¬μ‚¬λ” μµκ³ μ μ”λ¦¬λ¥Ό μ„ν•΄ μ λ²Όλ ¤μ§„ 'μ…°ν”„μ λ‚μ΄ν”„' ν•λ‚μ— μ§‘μ¤‘. μΉΌμ μ±…μ„μ€ 'μλ¥΄λ” κ²ƒ'μ— ν•μ •. μ½”λ¥΄ν¬λ¥Ό λ”°μ•Ό ν•λ‹¤λ©΄ μ½”λ¥΄ν¬μ¤ν¬λ£¨λ¥Ό μ‚¬μ©ν•μ§€, μΉΌλ΅ μ–µμ§€λ΅ λ”°λ ¤ ν•μ§€ μ•μ.
    
- **μ μ© μμ‹:**
    
    - **μ„λ° μ‚¬λ΅€:** `Employee` ν΄λμ¤κ°€ μ§μ›μ μ •λ³΄ κ΄€λ¦¬, κΈ‰μ—¬ κ³„μ‚°, λ°μ΄ν„°λ² μ΄μ¤ μ €μ¥ κΈ°λ¥μ„ λ¨λ‘ κ°€μ§.
        
        ```
        class Employee {
            public String name;
            public long basePay;
        
            public double calculatePay() { /*...*/ }
            public String getEmployeeReport() { /*...*/ }
            public void saveToDatabase() { /*...*/ }
        }
        ```
        
    - **μ¤€μ μ‚¬λ΅€:** μ±…μ„μ„ λ¶„λ¦¬ν•μ—¬ κ°κΈ° λ‹¤λ¥Έ λ³€κ²½ μ΄μ λ¥Ό κ°€μ§.
        
        - `EmployeeData` ν΄λμ¤: μ§μ›μ ν•µμ‹¬ λ°μ΄ν„°λ§ κ΄€λ¦¬.
            
        - `PayCalculator` ν΄λμ¤: κΈ‰μ—¬ κ³„μ‚° μ±…μ„.
            
        - `EmployeeRepository` ν΄λμ¤: λ°μ΄ν„°λ² μ΄μ¤ μ €μ¥ μ±…μ„.
            

#### **3. O: κ°λ°©-νμ‡„ μ›μΉ™ (Open/Closed Principle, OCP)**

> "μ†ν”„νΈμ›¨μ–΄ κ°μ²΄(ν΄λμ¤, λ¨λ“, ν•¨μ λ“±)λ” ν™•μ¥μ— λ€ν•΄ μ—΄λ ¤ μμ–΄μ•Ό ν•κ³ , μμ •μ— λ€ν•΄μ„λ” λ‹«ν€ μμ–΄μ•Ό ν•λ‹¤."

- **ν•µμ‹¬ κ°λ…:** κΈ°μ΅΄ μ½”λ“λ¥Ό μ§μ ‘ μμ •ν•μ§€ μ•κ³ λ„ μƒλ΅μ΄ κΈ°λ¥μ„ μ¶”κ°€ν•  μ μμ–΄μ•Ό ν•¨.
    
- **λ§λ“¤μ–΄μ§„ μ΄μ :** μ΄λ―Έ μ•μ •μ μΌλ΅ μ‘λ™ν•λ” μ½”λ“λ¥Ό μμ •ν•λ” κ²ƒμ€ λ²„κ·Έλ¥Ό μ λ°ν•  μ„ν—μ΄ νΌ. μƒλ΅μ΄ μ”κµ¬μ‚¬ν•­μ΄ μƒκΈΈ λ•λ§λ‹¤ κΈ°μ΅΄ μ½”λ“λ¥Ό κ±΄λ“λ¦¬λ” κ²ƒμ€ λΉ„ν¨μ¨μ μ΄κ³  μ„ν—.
    
- **λΉ„μ :** μ¤λ§νΈν°μ— μƒλ΅μ΄ κΈ°λ¥μ„ μ¶”κ°€ν•κ³  μ‹¶μ„ λ•, μ°λ¦¬λ” μ•± μ¤ν† μ–΄μ—μ„ μ•±μ„ 'μ„¤μΉ(ν™•μ¥)'ν•μ§€, μ¤λ§νΈν°μ λ©”μΈλ³΄λ“λ¥Ό λ―μ–΄μ„ νλ΅λ¥Ό 'λ‚©λ•(μμ •)'ν•μ§€ μ•μ.
    
- **μ μ© μμ‹:**
    
    - **μ„λ° μ‚¬λ΅€:** λ„ν•μ λ©΄μ μ„ κ³„μ‚°ν•λ” ν•¨μκ°€ `if-else`λ΅ λ¶„κΈ°. μƒλ΅μ΄ λ„ν•(μ: μ‚Όκ°ν•)μ„ μ¶”κ°€ν•λ ¤λ©΄ ν•¨μ μμ²΄λ¥Ό μμ •ν•΄μ•Ό ν•¨.
        
        ```
        class AreaCalculator {
            public double calculate(Object shape) {
                if (shape instanceof Rectangle) { /* μ‚¬κ°ν• λ©΄μ  κ³„μ‚° */ }
                if (shape instanceof Circle) { /* μ› λ©΄μ  κ³„μ‚° */ }
                // μƒλ΅μ΄ λ„ν• μ¶”κ°€ μ‹ μ΄ λ¶€λ¶„μ„ κ³„μ† μμ •ν•΄μ•Ό ν•¨
                return 0.0;
            }
        }
        ```
        
    - **μ¤€μ μ‚¬λ΅€:** `Shape` μΈν„°νμ΄μ¤(μ¶”μƒν™”)λ¥Ό λ§λ“¤κ³ , κ° λ„ν• ν΄λμ¤κ°€ μ΄λ¥Ό κµ¬ν„. `AreaCalculator`λ” μΈν„°νμ΄μ¤μ—λ§ μμ΅΄.
        
        ```
        interface Shape {
            double getArea();
        }
        class Rectangle implements Shape { /*...*/ }
        class Circle implements Shape { /*...*/ }
        
        // μƒλ΅μ΄ Triangle ν΄λμ¤λ¥Ό μ¶”κ°€ν•΄λ„ AreaCalculatorλ” μμ •ν•  ν•„μ”κ°€ μ—†μ
        class AreaCalculator {
            public double calculate(Shape shape) {
                return shape.getArea();
            }
        }
        ```
        

#### **4. L: λ¦¬μ¤μ½”ν”„ μΉν™ μ›μΉ™ (Liskov Substitution Principle, LSP)**

> "μ„λΈνƒ€μ…μ€ μ–Έμ λ‚ κ·Έκ²ƒμ κΈ°λ° νƒ€μ…μΌλ΅ κµμ²΄λ  μ μμ–΄μ•Ό ν•λ‹¤."

- **ν•µμ‹¬ κ°λ…:** μμ‹ ν΄λμ¤λ” λ¶€λ¨ ν΄λμ¤κ°€ μ‚¬μ©λλ” κ³³ μ–΄λ””μ—μ„λ“  λ™μΌν•κ² μ‘λ™ν•΄μ•Ό ν•¨. μ¦‰, μμ‹ ν΄λμ¤κ°€ λ¶€λ¨ ν΄λμ¤μ ν–‰λ™ κ·μ•½μ„ μ–΄κ²¨μ„λ” μ• λ¨.
    
- **λ§λ“¤μ–΄μ§„ μ΄μ :** μƒμ†μ„ μλ» μ‚¬μ©ν•λ©΄ μμΈ΅ λ¶κ°€λ¥ν• λ²„κ·Έκ°€ λ°μƒ. μƒμ†μ€ 'IS-A' κ΄€κ³„λ¥Ό ν‘ν„ν•μ§€λ§, λ¨λ“  'IS-A' κ΄€κ³„κ°€ μ½”λ“μƒμ—μ„ μ¬λ°”λ¥Έ μƒμ†μΌλ΅ μ΄μ–΄μ§€μ§€λ” μ•κΈ° λ•λ¬Έ.
    
- **λΉ„μ :** 'μ¤λ§νΈ TV'λ” 'TV'μ ν• μΆ…λ¥(μ„λΈνƒ€μ…). TV λ¦¬λ¨μ»¨μΌλ΅ μ¤λ§νΈ TVλ¥Ό μ΅°μ‘ν•  λ•, μ „μ› λ²„νΌμ„ λ„λ¥΄λ©΄ λ‹Ήμ—°ν μ „μ›μ΄ μΌμ§€κ±°λ‚ κΊΌμ Έμ•Ό ν•¨. λ§μ•½ μ „μ› λ²„νΌμ΄ λ―Έμ‚¬μΌμ„ λ°μ‚¬ν•λ‹¤λ©΄, μ΄λ” λ¦¬λ¨μ»¨ μ‚¬μ©μμ κΈ°λ€λ¥Ό μ™„μ „ν μ €λ²„λ¦¬λ” ν–‰λ™μ΄λ©° LSP μ„λ°.
    
- **μ μ© μμ‹:**
    
    - **μ„λ° μ‚¬λ΅€:** `Square`(μ •μ‚¬κ°ν•) ν΄λμ¤κ°€ `Rectangle`(μ§μ‚¬κ°ν•) ν΄λμ¤λ¥Ό μƒμ†. μ§μ‚¬κ°ν•μ€ λ„λΉ„μ™€ λ†’μ΄λ¥Ό λ…λ¦½μ μΌλ΅ μ„¤μ •ν•  μ μμ§€λ§, μ •μ‚¬κ°ν•μ€ λ„λΉ„λ¥Ό λ°”κΎΈλ©΄ λ†’μ΄λ„ ν•¨κ» λ°”λ€μ–΄μ•Ό ν•¨. μ΄λ” λ¶€λ¨ ν΄λμ¤μ ν–‰λ™ κ·μ•½μ„ κΉ¨λ¨λ¦¬λ” κ²ƒ.
        
        ```
        void someFunction(Rectangle r) {
            r.setWidth(10);
            r.setHeight(5);
            // rμ΄ Square κ°μ²΄μ€λ‹¤λ©΄, λ„λΉ„μ™€ λ†’μ΄κ°€ κ°™μ•„μ•Ό ν•λ‹¤λ” κ·μΉ™ λ•λ¬Έμ—
            // μ΄ ν•¨μμ κ²°κ³Όλ” μμΈ΅κ³Ό λ‹¬λΌμ§ (λ„“μ΄κ°€ 50μ΄ μ•„λ‹ μ μμ)
            assert r.getArea() == 50;
        }
        ```
        
    - **μ¤€μ μ‚¬λ΅€:** μƒμ† κ΄€κ³„λ¥Ό μ¬κ³ ν•κ±°λ‚, κ³µν†µμ `Shape` μΈν„°νμ΄μ¤λ¥Ό μ‚¬μ©ν•λ„λ΅ κµ¬μ΅°λ¥Ό λ³€κ²½.
        

#### **5. I: μΈν„°νμ΄μ¤ λ¶„λ¦¬ μ›μΉ™ (Interface Segregation Principle, ISP)**

> "ν΄λΌμ΄μ–ΈνΈλ” μμ‹ μ΄ μ‚¬μ©ν•μ§€ μ•λ” λ©”μ„λ“μ— μμ΅΄ν•λ„λ΅ κ°•μ”λ°›μ•„μ„λ” μ• λλ‹¤."

- **ν•µμ‹¬ κ°λ…:** ν•λ‚μ κ±°λ€ν• 'λ§λ¥ μΈν„°νμ΄μ¤'λ³΄λ‹¤, μ—­ν• μ— λ”°λΌ μκ² μΌκ°μ§„ μ—¬λ¬ κ°μ 'μ „μ© μΈν„°νμ΄μ¤'κ°€ λ” μΆ‹μ.
    
- **λ§λ“¤μ–΄μ§„ μ΄μ :** λ¶ν•„μ”ν•κ² κ±°λ€ν• μΈν„°νμ΄μ¤λ” ν•΄λ‹Ή μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•λ” ν΄λμ¤μ—κ² μ‚¬μ©ν•μ§€λ„ μ•μ„ λ©”μ„λ“λ¥Ό κ°•μ λ΅ κµ¬ν„ν•κ² λ§λ“¦. μ΄λ” λ¶ν•„μ”ν• κ²°ν•©μ„ λ§λ“¤κ³  μ‹μ¤ν…μ„ κ²½μ§μ‹ν‚΄.
    
- **λΉ„μ :** λ μ¤ν† λ‘μ—μ„ μ»¤ν”Όλ§ λ§μ‹λ¬ κ°”λ”λ°, μ•„μΉ¨, μ μ‹¬, μ €λ…, μλ£, λ””μ €νΈκ°€ λ¨λ‘ λ‹΄κΈ΄ κ±°λ€ν• μ±… ν• κ¶ λ¶„λ‰μ λ©”λ‰΄νμ„ λ°›λ” μƒν™©. λ‹¨μ§€ 'μλ£ λ©”λ‰΄'λ§ λ°›λ” κ²ƒμ΄ ν›¨μ”¬ ν¨μ¨μ .
    
- **μ μ© μμ‹:**
    
    - **μ„λ° μ‚¬λ΅€:** `IWorker` μΈν„°νμ΄μ¤μ— `work()`μ™€ `eat()` λ©”μ„λ“κ°€ λ¨λ‘ ν¬ν•¨. `HumanWorker`λ” λ‘ λ‹¤ κµ¬ν„ κ°€λ¥ν•μ§€λ§, `RobotWorker`λ” `eat()`μ„ ν•  μ μ—†μμ—λ„ μ–µμ§€λ΅ κµ¬ν„ν•΄μ•Ό ν•¨.
        
        ```
        interface IWorker {
            void work();
            void eat();
        }
        class RobotWorker implements IWorker {
            public void work() { /* μΌν•κΈ° */ }
            public void eat() { /* μ•„λ¬΄κ²ƒλ„ μ• ν•¨. λ¶ν•„μ”ν• κµ¬ν„ */ }
        }
        ```
        
    - **μ¤€μ μ‚¬λ΅€:** μΈν„°νμ΄μ¤λ¥Ό μ—­ν• μ— λ”°λΌ λ¶„λ¦¬.
        
        ```
        interface IWorkable { void work(); }
        interface IEatable { void eat(); }
        
        class HumanWorker implements IWorkable, IEatable { /*...*/ }
        class RobotWorker implements IWorkable { /*...*/ }
        ```
        

#### **6. D: μμ΅΄κ΄€κ³„ μ—­μ „ μ›μΉ™ (Dependency Inversion Principle, DIP)**

> "μƒμ„ μμ¤€ λ¨λ“μ€ ν•μ„ μμ¤€ λ¨λ“μ— μμ΅΄ν•΄μ„λ” μ• λλ‹¤. λ‘ λ¨λ‘ μ¶”μƒν™”μ— μμ΅΄ν•΄μ•Ό ν•λ‹¤." "μ¶”μƒν™”λ” μ„Έλ¶€ μ‚¬ν•­μ— μμ΅΄ν•΄μ„λ” μ• λλ‹¤. μ„Έλ¶€ μ‚¬ν•­μ΄ μ¶”μƒν™”μ— μμ΅΄ν•΄μ•Ό ν•λ‹¤."

- **ν•µμ‹¬ κ°λ…:** κµ¬μ²΄μ μΈ κµ¬ν„ ν΄λμ¤μ— μ§μ ‘ μμ΅΄ν•μ§€ λ§κ³ , μΈν„°νμ΄μ¤λ‚ μ¶”μƒ ν΄λμ¤ κ°™μ€ 'μ¶”μƒν™”'μ— μμ΅΄.
    
- **λ§λ“¤μ–΄μ§„ μ΄μ :** μƒμ„ μ •μ±…(λΉ„μ¦λ‹μ¤ λ΅μ§)μ΄ ν•μ„ κµ¬ν„(μ„Έλ¶€ κΈ°μ )μ λ³€κ²½μ— μ§μ ‘μ μΌλ΅ μν–¥μ„ λ°›μ§€ μ•λ„λ΅ ν•κΈ° μ„ν•¨. μ‹μ¤ν…μ κ° λ¶€λ¶„μ„ λ…λ¦½μ μΈ λ¶€ν’μ²λΌ κµμ²΄ν•  μ μκ² λ§λ“¤μ–΄ μ μ—°μ„±μ„ κ·Ήλ€ν™”.
    
- **λΉ„μ :** λ¨ν”„λ¥Ό μ§‘μ μ „κΈ° λ°°μ„ μ— μ§μ ‘ λ‚©λ•ν•μ§€ μ•μ. λ€μ‹  'ν”λ¬κ·Έ'μ™€ 'μ½μ„ΌνΈ'λΌλ” ν‘μ¤€ μΈν„°νμ΄μ¤(μ¶”μƒν™”)λ¥Ό μ‚¬μ©. λ¨ν”„(μƒμ„ λ¨λ“)μ™€ μ „κΈ° λ°°μ„ (ν•μ„ λ¨λ“)μ€ λ¨λ‘ μ΄ ν‘μ¤€ μΈν„°νμ΄μ¤μ— μμ΅΄. λ•λ¶„μ— μ–΄λ–¤ μ μ΅°μ‚¬μ λ¨ν”„λ“  μ½μ„ΌνΈμ— κ½‚μ•„ μ‚¬μ©ν•  μ μμ.
    
- **μ μ© μμ‹:**
    
    - **μ„λ° μ‚¬λ΅€:** `Notification` ν΄λμ¤κ°€ `EmailSender`λΌλ” κµ¬μ²΄μ μΈ ν΄λμ¤λ¥Ό μ§μ ‘ μƒμ„±ν•κ³  μ‚¬μ©. λ‚μ¤‘μ— SMSλ΅ μ•λ¦Ό λ°©μ‹μ„ λ°”κΎΈλ ¤λ©΄ `Notification` ν΄λμ¤ μ½”λ“λ¥Ό μ§μ ‘ μμ •ν•΄μ•Ό ν•¨.
        
        ```
        class Notification {
            private EmailSender emailSender = new EmailSender();
        
            public void send() {
                emailSender.sendEmail();
            }
        }
        ```
        
    - **μ¤€μ μ‚¬λ΅€:** `MessageSender`λΌλ” μΈν„°νμ΄μ¤λ¥Ό λ§λ“¤κ³ , `Notification` ν΄λμ¤λ” μ΄ μΈν„°νμ΄μ¤μ—λ§ μμ΅΄. μ‹¤μ  μ‚¬μ©ν•  `EmailSender`λ‚ `SmsSender` κ°μ²΄λ” μ™Έλ¶€μ—μ„ μ£Όμ…(Dependency Injection).
        
        ```
        interface MessageSender {
            void send();
        }
        class Notification {
            private MessageSender sender;
        
            // μƒμ„±μλ¥Ό ν†µν•΄ μμ΅΄μ„± μ£Όμ…
            public Notification(MessageSender sender) {
                this.sender = sender;
            }
        
            public void send() {
                sender.send();
            }
        }
        ```
        

SOLID μ›μΉ™λ“¤μ€ κ²°κµ­ μΆ‹μ€ μ„¤κ³„λ¥Ό μ„ν• λ„κµ¬ μƒμμ…λ‹λ‹¤. κ° μ›μΉ™μ΄ μ–΄λ–¤ λ¬Έμ λ¥Ό ν•΄κ²°ν•κΈ° μ„ν•΄ λ§λ“¤μ–΄μ΅λ”μ§€ μ΄ν•΄ν•λ‹¤λ©΄, λ” κ²¬κ³ ν•κ³  μ μ—°ν• μ†ν”„νΈμ›¨μ–΄λ¥Ό λ§λ“λ” λ° ν° λ„μ›€μ΄ λ  κ²ƒμ…λ‹λ‹¤.

μ΄ μ›μΉ™λ“¤ μ¤‘μ—μ„ νΉλ³„ν λ” κ¶κΈν•κ±°λ‚ μ‹¤μ  ν”„λ΅μ νΈμ— μ μ©ν•λ” λ° μ–΄λ ¤μ›€μ„ λλΌλ” λ¶€λ¶„μ΄ μμΌμ‹ κ°€μ”?
## References
[[5-π’ μκµ¬ λ…ΈνΈ/SOLID]]