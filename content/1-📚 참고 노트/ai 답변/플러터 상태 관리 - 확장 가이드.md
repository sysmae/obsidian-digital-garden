---
publish: true
---

<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" class="logo" width="120"/>

# 4.3 상태 관리 - 확장 가이드

## 개요

Flutter에서 **상태 관리**는 앱의 데이터와 UI 상태를 체계적으로 관리하는 핵심 개념이다[^1][^2]. 상태는 앱의 '기억'으로, 사용자 로그인 정보, 화면 전환, 폼 입력 데이터 등 시간에 따라 변화하는 모든 정보를 포함한다[^3][^4]. 효과적인 상태 관리는 **확장성, 유지보수성, 테스트 용이성**을 보장하는 핵심 요소이다[^1][^5].

## 상태 유형 분류

Flutter 상태는 크게 두 가지로 분류된다[^6][^2]:


| 상태 유형 | 특성 | 관리 방법 | 예시 |
| :-- | :-- | :-- | :-- |
| **Ephemeral State** | 지역적, 임시적[^6][^3] | `StatefulWidget`, `setState()`[^6][^2] | 텍스트 필드 입력, 체크박스 상태[^3] |
| **App State** | 전역적, 지속적[^6][^3] | Provider, Riverpod, Bloc 등[^1][^7] | 사용자 인증, 테마 설정, 장바구니[^3] |

## 주요 상태 관리 라이브러리 비교

### Provider vs Riverpod vs Bloc

| 구분             | Provider      | Riverpod          | Bloc                |
| :------------- | :------------ | :---------------- | :------------------ |
| **학습 곡선**      | 쉬움[^1][^7]    | 중간[^8][^9]        | 어려움[^1][^8]         |
| **보일러플레이트**    | 적음[^1][^10]   | 적음[^8][^11]       | 많음[^11][^10]        |
| **컴파일 타임 안전성** | 제한적[^9][^12]  | 강력[^8][^9]        | 강력[^1][^12]         |
| **의존성 주입**     | 위젯 트리 기반[^10] | 전역 프로바이더[^9][^10] | 이벤트-스트림 기반[^8][^13] |
| **적합한 프로젝트**   | 소-중규모[^1][^7] | 중-대규모[^8][^12]    | 대규모, 엔터프라이즈[^1][^8] |

### Provider: 간편함의 대명사

**Provider**는 Flutter 공식 권장 상태 관리 솔루션으로, `InheritedWidget`을 기반으로 한다[^13][^14].

```dart
// ChangeNotifier 기반 상태 클래스
class CounterModel extends ChangeNotifier {
  int _count = 0;
  int get count => _count;
  
  void increment() {
    _count++;
    notifyListeners(); // UI 재빌드 트리거
  }
}

// 위젯에서 사용
Consumer<CounterModel>(
  builder: (context, counter, child) {
    return Text('Count: ${counter.count}');
  },
)
```

**장점**: 간단한 학습 곡선, 최소한의 보일러플레이트, Flutter 공식 지원[^1][^10]
**단점**: 런타임 에러 가능성, 위젯 트리 의존성[^10]

### Riverpod: 타입 안전성의 혁신

**Riverpod**은 Provider의 진화된 형태로, 컴파일 타임 안전성과 전역 프로바이더를 제공한다[^8][^9].

```dart
// StateNotifier 기반 (Bloc의 Cubit과 유사)
@riverpod
class Counter extends _$Counter {
  @override
  int build() => 0;
  
  void increment() => state++;
}

// 위젯에서 사용
final count = ref.watch(counterProvider);
ref.read(counterProvider.notifier).increment();
```

**장점**: 컴파일 타임 안전성, BuildContext 불필요, 모듈형 구조[^8][^12]
**단점**: 상대적으로 새로운 패키지, 코드 생성 필요[^8]

### Bloc: 엔터프라이즈급 구조

**Bloc**은 이벤트-상태 기반의 예측 가능한 상태 관리를 제공한다[^1][^13].

```dart
// 이벤트 정의
abstract class CounterEvent {}
class Increment extends CounterEvent {}

// Bloc 구현
class CounterBloc extends Bloc<CounterEvent, int> {
  CounterBloc() : super(0) {
    on<Increment>((event, emit) => emit(state + 1));
  }
}

// 위젯에서 사용
BlocBuilder<CounterBloc, int>(
  builder: (context, count) => Text('Count: $count'),
)
```

**장점**: 엄격한 아키텍처, 뛰어난 테스트 용이성, 복잡한 상태 플로우 관리[^1][^13]
**단점**: 높은 학습 곡선, 많은 보일러플레이트[^11][^10]

## MVVM과 Clean Architecture 통합

첨부된 문서에 따르면, Flutter 앱은 **UI 레이어**와 **Data 레이어**로 구분되며, MVVM 패턴을 기반으로 한다:

### UI 레이어 (Presentation Layer)

- **View**: 위젯 구성, 사용자 인터페이스[^15][^16]
- **ViewModel**: 비즈니스 로직, 상태 관리, 데이터 변환[^15][^16]


### Data 레이어 (Model Layer)

- **Repository**: 데이터의 단일 진실 공급원(Single Source of Truth)[^15]
- **Service**: 외부 API, 로컬 저장소와의 상호작용[^15]


### 의존성 주입과 테스트 용이성

**GetIt + Injectable** 조합은 Flutter에서 의존성 주입을 자동화한다[^17][^18][^19]:

```dart
// Injectable을 통한 자동 의존성 등록
@injectable
class UserRepository {
  final ApiService _apiService;
  UserRepository(this._apiService);
}

@singleton
class ApiService {}

// GetIt 설정
final getIt = GetIt.instance;

@InjectableInit()
void configureDependencies() => getIt.init();
```

**의존성 주입의 이점**[^18][^19]:

- **모듈성**: 각 레이어 간 결합도 감소
- **테스트 용이성**: 목 객체(Mock) 주입 가능
- **확장성**: 새로운 구현체 교체 용이


## 2025년 모범 사례

### 하이브리드 상태 전략

**지역 상태**는 `StatefulWidget`으로, **전역 상태**는 구조화된 라이브러리로 관리[^2]:

```dart
// 지역 상태: UI 전용
class _FormPageState extends State<FormPage> {
  bool _isVisible = false; // 모달 표시 여부
}

// 전역 상태: 비즈니스 로직
@riverpod
class UserSession extends _$UserSession {
  @override
  User? build() => null;
  
  Future<void> login(String email, String password) async {
    // 인증 로직
  }
}
```


### 불변성 우선 원칙

상태 객체는 **불변(immutable)**으로 설계하여 예측 가능성을 높인다[^2]:

```dart
@freezed
class UserState with _$UserState {
  const factory UserState({
    required bool isLoading,
    User? user,
    String? error,
  }) = _UserState;
}
```


### 성능 최적화 기법

- **Scoped Rebuilds**: `Consumer`, `Selector` 활용으로 불필요한 리빌드 방지[^2]
- **RepaintBoundary**: 독립적인 렌더링 영역 설정
- **const 생성자**: 컴파일 타임 최적화[^5]


## 라이브러리 선택 가이드

| 프로젝트 특성 | 권장 솔루션 | 이유 |
| :-- | :-- | :-- |
| **소규모, 학습용** | Provider[^1][^7] | 간단한 API, 공식 지원 |
| **중-대규모, 타입 안전성 중시** | Riverpod[^8][^12] | 컴파일 타임 안전성, 모듈성 |
| **엔터프라이즈, 복잡한 상태 플로우** | Bloc[^1][^8] | 엄격한 아키텍처, 예측 가능성 |
| **빠른 프로토타이핑** | GetX[^7] | 최소 보일러플레이트 |

**핵심 권장사항:**
상태 관리는 **프로젝트 규모와 팀 역량**에 맞게 선택해야 한다. **MVVM 아키텍처**와 **의존성 주입**을 통해 레이어를 분리하고, **불변 상태 패턴**을 적용하여 유지보수성을 확보한다. 특히 **하이브리드 전략**을 통해 지역 상태와 전역 상태를 적절히 구분하여 관리하는 것이 2025년 Flutter 개발의 핵심이다.

<div style="text-align: center">⁂</div>

[^1]: https://www.technaureus.com/blog-detail/state-management-in-flutter-a-comprehensive-guide

[^2]: https://vibe-studio.ai/insights/state-management-in-flutter-best-practices-for-2025

[^3]: https://www.infydots.com/flutter-state-management-complete-guide

[^4]: https://solguruz.com/blog/essential-guide-on-flutter-state-management/

[^5]: https://www.techaheadcorp.com/blog/master-state-management-in-flutter-best-practices-and-patterns/

[^6]: https://docs.flutter.dev/get-started/fundamentals/state-management

[^7]: https://vibe-studio.ai/insights/comparing-flutter-state-management-libraries-provider-bloc-riverpod-and-getx

[^8]: https://somniosoftware.com/blog/riverpod-vs-bloc-which-one-is-better-in-2024

[^9]: https://tech.appunite.com/posts/a-deep-dive-into-riverpod-vs-bloc

[^10]: https://dev.to/nkusikevin/state-of-the-art-state-management-compare-popular-patterns-provider-riverpod-bloc-35b5

[^11]: https://www.reddit.com/r/FlutterDev/comments/pjj40p/riverpod_vs_bloc/

[^12]: https://www.creolestudios.com/flutter-state-management-tool-comparison/

[^13]: https://www.f22labs.com/blogs/flutter-architecture-patterns-bloc-provider-riverpod-and-more/

[^14]: https://dev.to/sushan_dristi_ab98c07ea8f/flutter-architecture-patterns-explained-3mp3

[^15]: https://jecklight.tistory.com/entry/MVVM-Clean-Architecture-Provider

[^16]: https://dev-yongsu.tistory.com/22

[^17]: https://dispatchersdotplayground.hashnode.dev/a-comparison-between-flutters-injectable-and-dagger-2-in-the-jvm-world

[^18]: https://www.dhiwise.com/post/exploring-flutter-tools-getit-injectable-and-autoroute

[^19]: https://resocoder.com/2020/02/04/injectable-flutter-dart-equivalent-to-dagger-angular-dependency-injection/

[^20]: https://swdy1233.tistory.com/289

[^21]: https://github.com/HarryHaiVn/Flutter-Clean-Architecture-MVVM

[^22]: https://boilerplate.tistory.com/73

[^23]: https://dev.to/tadaspetra/complete-guide-to-state-management-218a

[^24]: https://tyeom.github.io/flutter/2023/11/29/Flutter-Clean-Architecture-적용해보기.html

[^25]: https://blog.stackademic.com/a-complete-guide-to-state-management-in-flutter-comparing-provider-riverpod-and-redux-d572ad9de25b

[^26]: https://techblog.lycorp.co.jp/ko/flutter-clean-architecture

[^27]: https://theonetechnologies.com/blog/post/mastering-state-management-in-flutter-a-comprehensive-guide

[^28]: https://www.dhiwise.com/post/flutter-insights-navigating-the-riverpod-vs-bloc-puzzle

[^29]: https://stackoverflow.com/questions/70630059/is-there-any-relationship-between-flutter-state-management-and-flutter-architect

[^30]: https://www.reddit.com/r/FlutterDev/comments/1f7tlrq/flutter_state_management_design_patterns_do_you/

[^31]: https://flutterbook.dev/article/Flutter_State_Management_Best_Practices_and_Techniques.html

[^32]: https://pub.dev/packages/injectable

[^33]: https://docs.flutter.dev/app-architecture/design-patterns

[^34]: https://ctoahn.tistory.com/15

[^35]: https://blog.flutter.wtf/flutter-mobile-app-testing-tools-and-strategy/

[^36]: https://docs.flutter.dev/data-and-backend/state-mgmt/options

[^37]: https://www.reddit.com/r/FlutterDev/comments/k1wk7r/dependency_injection/

[^38]: https://www.social.plus/tutorials/state-management-in-dart-flutter

[^39]: https://docs.flutter.dev/app-architecture

[^40]: https://velog.io/@aengzu/Flutter-DI-getit-정리하기

