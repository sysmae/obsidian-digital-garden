---
publish: true
---

'컴포넌트'에 관해 만들어진 이유에서 구조, 사용법 등을 통합한 하나의 핸드북 형식의 요약 만들어줘.

# 리액트 컴포넌트 핸드북: 만들어진 이유부터 사용법까지

## 컴포넌트란 무엇인가?

리액트에서 **컴포넌트는 사용자 인터페이스(UI)의 독립적이고 재사용 가능한 구성 요소**입니다[^1][^2]. 컴포넌트는 자바스크립트 함수와 유사한 역할을 하지만, 격리된 환경에서 작동하며 HTML을 반환합니다[^1].

컴포넌트는 "**UI 구성 요소의 빌딩 블록**"으로서, 버튼처럼 작은 요소부터 전체 페이지까지 다양한 크기로 구성될 수 있습니다[^2][^3]. 리액트 앱은 이러한 컴포넌트들이 조합되어 만들어집니다[^2].

## 컴포넌트가 만들어진 이유

### 1. 소프트웨어 위기 해결

컴포넌트 기반 개발의 개념은 1968년 더글라스 맥일로이(Douglas McIlroy)가 NATO 소프트웨어 엔지니어링 컨퍼런스에서 "Mass Produced Software Components"라는 제목으로 발표하면서 시작되었습니다[^4][^5]. 이는 당시의 **소프트웨어 위기도였습니다[^5].

### 2. 전통적인 개발 방식의 한계

전통적인 모놀리식 아키텍처에서는 다음과 같은 문제들이 있었습니다[^6]:

- 코드 유지보수의 어려움
- 확장성 부족
- 팀 협업의 비효율성
- 중복 코드 작성


### 3. 재사용성과 모듈화의 필요성

컴포넌트는 **"공장 조립과 같은 소프트웨어 개발"**을 가능하게 하여, 매번 새로운 코드를 작성하는 대신 **검증된 부품으로 소프트웨어를 조립**할 수 있게 해줍니다[^5].

## 컴포넌트의 구조와 특성

### 핵심 특성

리액트 컴포넌트는 다음과 같은 특성을 가집니다[^7][^8]:

**1. 캡슐화(Encapsulation)**

- 컴포넌트는 자신만의 로직과 상태를 내부에 포함합니다[^7]
- 내부 구현을 숨기고 필요한 인터페이스만 노출합니다[^8]

**2. 재사용성(Reusability)**

- 한 번 개발된 컴포넌트는 여러 곳에서 재사용 가능합니다[^7][^8]
- 개발 시간과 비용을 절약합니다[^7]

**3. 독립성(Independence)**

- 컴포넌트는 다른 컴포넌트에 과도하게 의존하지 않습니다[^7]
- 독립적으로 교체나 업그레이드가 가능합니다[^7]

**4. 상호 운용성(Interoperability)**

- 잘 정의된 인터페이스를 통해 다른 컴포넌트와 원활하게 상호작용합니다[^7]


## 컴포넌트의 종류

### 1. 함수형 컴포넌트 (Functional Components)

함수형 컴포넌트는 **자바스크립트 함수로 정의되는 더 간단한 형태**입니다[^9][^10]:

```javascript
function Car() {
  return <h2>Hi, I am a Car!</h2>;
}
```

**장점:**

- 더 간단하고 이해하기 쉬움[^9]
- React Hooks와 함께 사용 가능[^9]
- 더 가볍고 성능이 우수[^9]


### 2. 클래스형 컴포넌트 (Class Components)

클래스형 컴포넌트는 **ES6 클래스를 사용하여 정의**됩니다[^9][^10]:

```javascript
class Car extends React.Component {
  render() {
    return <h2>Hi, I am a Car!</h2>;
  }
}
```

**특징:**

- 전통적인 생명주기 메서드 사용[^9]
- 더 많은 기능을 제공하지만 복잡함[^9]
- 현재는 함수형 컴포넌트 사용이 권장됨[^9]


## 컴포넌트의 핵심 개념

### 1. Props (속성)

Props는 **부모 컴포넌트가 자식 컴포넌트에게 전달하는 데이터**입니다[^11][^12]:

```javascript
// 부모 컴포넌트
function App() {
  return <Child name="mitt" age={28} />;
}

// 자식 컴포넌트
function Child(props) {
  return (
    <div>
      <p>Name: {props.name}</p>
      <p>Age: {props.age}</p>
    </div>
  );
}
```

**Props의 특징:**

- **읽기 전용**(Read-Only)[^13][^11]
- 컴포넌트 간 데이터 전달에 사용[^11]
- 부모에서 자식으로의 단방향 데이터 흐름[^11]


### 2. State (상태)

State는 **컴포넌트 내부에서 관리되는 동적 데이터**입니다[^14][^11]:

```javascript
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}
```

**State의 특징:**

- 컴포넌트 내부에서 변경 가능[^14][^11]
- 상태가 변경되면 컴포넌트가 다시 렌더링됨[^14]
- useState Hook을 통해 함수형 컴포넌트에서 사용[^14]


### 3. JSX (JavaScript XML)

JSX는 **자바스크립트 안에서 HTML과 유사한 문법을 사용할 수 있게 해주는 구문 확장**입니다[^15][^16]:

```javascript
const element = <h1>Hello, world!</h1>;
```

**JSX의 특징:**

- HTML과 자바스크립트를 결합[^15][^16]
- Babel에 의해 React.createElement() 호출로 변환[^16]
- 중괄호 `{}`를 사용하여 자바스크립트 표현식 삽입 가능[^15]


## 컴포넌트 생명주기

### 클래스형 컴포넌트의 생명주기

리액트 컴포넌트는 **마운팅(Mounting), 업데이팅(Updating), 언마운팅(Unmounting)** 세 단계를 거칩니다[^17][^18]:

**1. 마운팅 단계**

- `constructor()`: 컴포넌트 초기화[^17]
- `componentDidMount()`: DOM 추가 후 실행[^17]

**2. 업데이팅 단계**

- `shouldComponentUpdate()`: 리렌더링 여부 결정[^17]
- `componentDidUpdate()`: 업데이트 후 실행[^17]

**3. 언마운팅 단계**

- `componentWillUnmount()`: 컴포넌트 제거 전 실행[^17]


### 함수형 컴포넌트의 Hooks

함수형 컴포넌트에서는 **useEffect Hook**을 사용하여 생명주기를 관리합니다[^19][^20]:

```javascript
import React, { useEffect, useState } from 'react';

function MyComponent() {
  const [count, setCount] = useState(0);

  // 마운트 시 실행 (빈 배열)
  useEffect(() => {
    console.log('Component mounted');
  }, []);

  // count 변경 시 실행
  useEffect(() => {
    console.log('Count changed:', count);
  }, [count]);

  // 언마운트 시 실행 (cleanup function)
  useEffect(() => {
    return () => {
      console.log('Component will unmount');
    };
  }, []);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}
```


## 컴포넌트 사용법과 모범 사례

### 1. 컴포넌트 명명 규칙

리액트 컴포넌트는 **대문자로 시작**해야 합니다[^2][^21]:

```javascript
// 올바른 방법
function MyButton() {
  return <button>Click me</button>;
}

// 잘못된 방법
function myButton() {
  return <button>Click me</button>;
}
```


### 2. 단일 책임 원칙

각 컴포넌트는 **하나의 기능에만 집중**해야 합니다[^22][^23]:

```javascript
// 좋은 예: 단일 책임
function UserAvatar({ user }) {
  return <img src={user.avatar} alt={user.name} />;
}

function UserName({ user }) {
  return <h2>{user.name}</h2>;
}
```


### 3. Props 검증

TypeScript나 PropTypes를 사용하여 **props를 검증**합니다[^24][^21]:

```javascript
import PropTypes from 'prop-types';

function Greeting({ name, age }) {
  return <h1>Hello {name}, you are {age} years old!</h1>;
}

Greeting.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};
```


### 4. 컴포넌트 조합 활용

**children props**를 활용하여 컴포넌트를 조합합니다[^21]:

```javascript
function Container({ children }) {
  return <div className="container">{children}</div>;
}

function App() {
  return (
    <Container>
      <h1>Title</h1>
      <p>Content goes here</p>
    </Container>
  );
}
```


## 재사용 가능한 컴포넌트의 이점

### 1. 개발 효율성 향상

재사용 가능한 컴포넌트는 **개발 시간을 최대 60% 단축**할 수 있습니다[^25]. 한 번 작성된 컴포넌트를 여러 곳에서 사용함으로써 중복 작업을 제거합니다[^26][^27].

### 2. 일관성 유지

동일한 컴포넌트를 사용함으로써 **애플리케이션 전체의 디자인과 동작 일관성**을 보장할 수 있습니다[^26][^27].

### 3. 유지보수성 개선

컴포넌트가 독립적으로 구성되어 있어 **버그 수정이나 기능 개선이 용이**합니다[^28][^27]. 한 곳에서 수정하면 해당 컴포넌트를 사용하는 모든 곳에 반영됩니다[^25].

### 4. 성능 최적화

재사용 가능한 컴포넌트는 **메모이제이션과 지연 로딩** 등의 기법을 활용하여 성능을 향상시킬 수 있습니다[^26].

## 컴포넌트의 미래와 발전 방향

### 1. 함수형 컴포넌트와 Hooks의 확산

현재 리액트는 **함수형 컴포넌트와 Hooks 사용을 권장**하고 있습니다[^21]. 이는 더 간단하고 직관적인 코드 작성을 가능하게 합니다[^9].

### 2. 컴포넌트 라이브러리 생태계

**Storybook과 같은 도구**를 활용하여 컴포넌트를 독립적으로 개발하고 문서화하는 방식이 보편화되고 있습니다[^29].

### 3. 마이크로 프론트엔드 아키텍처

컴포넌트 기반 아키텍처는 **마이크로 프론트엔드**로 발전하여, 각 팀이 독립적으로 컴포넌트를 개발하고 배포할 수 있게 됩니다[^6].

## 결론

리액트 컴포넌트는 **소프트웨어 위기를 해결하기 위한 모듈화 개념**에서 출발하여, 현재는 **현대 웹 개발의 핵심 패러다임**이 되었습니다. 컴포넌트는 재사용성, 유지보수성, 확장성을 제공하며, 개발자들이 더 효율적이고 일관된 사용자 인터페이스를 구축할 수 있게 해줍니다.

함수형 컴포넌트와 Hooks의 도입으로 컴포넌트는 더욱 간단하고 강력해졌으며, 앞으로도 웹 개발의 중심 역할을 계속할 것으로 예상됩니다. 올바른 컴포넌트 설계 원칙을 따르고 모범 사례를 적용한다면, 확장 가능하고 유지보수가 용이한 애플리케이션을 구축할 수 있습니다.

<div style="text-align: center">⁂</div>

[^1]: https://www.w3schools.com/react/react_components.asp

[^2]: https://react.dev/learn

[^3]: https://react.dev/learn/your-first-component

[^4]: https://arxiv.org/pdf/1011.2163.pdf

[^5]: https://en.wikipedia.org/wiki/Software_component

[^6]: https://www.linkedin.com/pulse/benefits-transitioning-component-based-architecture-vintageglobal-qpwoe

[^7]: https://www.linkedin.com/pulse/types-software-components-examples-sunny-yadav-ducaf

[^8]: https://www.tutorialspoint.com/software_architecture_design/component_based_architecture.htm

[^9]: https://www.geeksforgeeks.org/blogs/differences-between-functional-components-and-class-components/

[^10]: https://www.freecodecamp.org/news/function-component-vs-class-component-in-react/

[^11]: https://kindjjee.tistory.com/102

[^12]: https://react.dev/learn/passing-props-to-a-component

[^13]: https://gseok.gitbooks.io/react/content/bd80-bd84-bd80-bd84-c9c0-c2dd-b4e4/react-propsc640-state-ac1c-b150-c815-b9ac.html

[^14]: https://suzzeong.tistory.com/133

[^15]: https://www.w3schools.com/react/react_jsx.asp

[^16]: https://www.geeksforgeeks.org/reactjs/reactjs-jsx-introduction/

[^17]: https://www.geeksforgeeks.org/reactjs/reactjs-lifecycle-components/

[^18]: https://www.freecodecamp.org/news/react-component-lifecycle-methods/

[^19]: https://wonyong-jang.github.io/react-redux/2021/05/21/React-useState-useEffect.html

[^20]: https://ko.react.dev/reference/react/useEffect

[^21]: https://e-bwp.com/eurostyl/photos/file/difegofomo-kepase.pdf

[^22]: https://www.geeksforgeeks.org/what-is-component-design/

[^23]: https://www.uxpin.com/studio/blog/react-best-practices/

[^24]: https://www.uxpin.com/studio/blog/how-to-build-reusable-react-components/

[^25]: https://dzone.com/articles/6-advantages-of-component-based-development

[^26]: https://dev.to/leoneloliver/the-power-of-reusable-components-in-react-2d79

[^27]: https://astconsulting.in/java-script/react-js/guide-modular-react-component-design

[^28]: https://www.linkedin.com/pulse/implementing-component-based-architecture-benefits-challenges-mf5re

[^29]: https://dev.to/begenchg/efficient-workflow-in-frontend-development-with-reactjs-4bdg

[^30]: https://sam-solutions.com/blog/what-is-component-based-architecture/

[^31]: https://help.sap.com/docs/SAP_NETWEAVER_702/ff53b41d6c551014aeed80b2b29e17cd/4911dbcccf292810e10000000a42189c.html

[^32]: https://www.techtarget.com/whatis/definition/component

[^33]: https://automotive.wiki/index.php/Software_Component

[^34]: https://www.geeksforgeeks.org/system-design/component-based-architecture-system-design/

[^35]: https://www.sciencedirect.com/topics/engineering/software-component

[^36]: https://marutitech.com/guide-to-component-based-architecture/

[^37]: https://www.seonens.com/view/archive_d?i=298

[^38]: https://www.geeksforgeeks.org/software-engineering/difference-between-module-and-software-component/

[^39]: https://roadmap.sh/software-design-architecture/architectural-principles/component-principles

[^40]: https://www.sciencedirect.com/topics/computer-science/software-component

[^41]: https://www.open.edu/openlearn/science-maths-technology/approaches-software-development/content-section-1.6.2

[^42]: https://www.linkedin.com/pulse/comprehensive-guide-component-based-architecture-brandon-opere-k2ite

[^43]: https://swansoftwaresolutions.com/the-basic-components-of-software-development/

[^44]: https://blog.pixelfreestudio.com/how-to-use-design-patterns-with-component-based-architecture/

[^45]: https://en.wikipedia.org/wiki/Component-based_software_engineering

[^46]: https://www.geeksforgeeks.org/system-design/software-design-patterns/

[^47]: https://jsaer.com/download/vol-8-iss-7-2021/JSAER2021-8-7-261-264.pdf

[^48]: https://www.linearloop.io/blog/component-driven-development

[^49]: https://www.ijarcs.info/index.php/Ijarcs/article/download/2757/2745

[^50]: https://bytebytego.com/guides/6-software-architectural-patterns-you-must-know/

[^51]: https://figshare.swinburne.edu.au/articles/conference_contribution/Components_the_past_the_present_and_the_future/26261414

[^52]: https://moldstud.com/articles/p-exploring-the-benefits-and-limitations-of-component-based-software-architecture

[^53]: https://scispace.com/pdf/components-the-past-the-present-and-the-future-6nqwv3g1wm.pdf

[^54]: https://www.sencha.com/blog/top-architecture-pattern-used-in-modern-enterprise-software-development/

[^55]: https://blog.pixelfreestudio.com/benefits-of-component-based-architecture-for-scalable-web-applications/

[^56]: https://icsa-conferences.org/series/CBSE/1999/papers/29/29.htm

[^57]: https://www.turing.com/blog/software-architecture-patterns-types

[^58]: https://en.wikipedia.org/wiki/Software_design_pattern

[^59]: https://www.sitepoint.com/getting-started-react-beginners-guide/

[^60]: https://www.xenonstack.com/blog/functional-vs-class-components

[^61]: https://dev.to/chintanonweb/write-react-components-like-a-pro-a-beginners-blueprint-4b1d

[^62]: https://trustmitt.tistory.com/59

[^63]: https://stackoverflow.com/questions/59841274/what-type-of-components-should-i-use-in-react-functional-components-or-class-ba

[^64]: https://studyingych.tistory.com/52

[^65]: https://react.dev/reference/react/Component

[^66]: https://dev.to/nziokidennis/react-a-comprehensive-guide-to-beginners-1nh0

[^67]: https://www.robinwieruch.de/react-component-types/

[^68]: https://javascript.plainenglish.io/react-components-and-props-explained-for-non-devs-d801399ed429

[^69]: https://velog.io/@soyi47/React-Component-props-state

[^70]: https://mihee0703.tistory.com/186

[^71]: https://www.w3schools.com/react/react_lifecycle.asp

[^72]: https://velog.io/@khy4018/React-useState-useEffect

[^73]: https://www.creolestudios.com/how-react-native-reusable-components-boost-app-development/

[^74]: https://legacy.reactjs.org/docs/react-component.html

[^75]: https://legacy.reactjs.org/docs/state-and-lifecycle.html

[^76]: https://html-jc.tistory.com/626

[^77]: https://javascript.plainenglish.io/mastering-reusability-in-react-building-clean-scalable-components-1caf571169d6

[^78]: https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

[^79]: https://heeeming.tistory.com/entry/React-React-hooks-정리-part1-useState-useEffect-useRef-useContext-Context-API

[^80]: https://dev.to/jps27cse/understanding-reusable-components-and-the-dry-principle-4ijm

[^81]: https://www.theodinproject.com/lessons/node-path-react-new-component-lifecycle-methods

[^82]: https://hawnbin.tistory.com/6

[^83]: https://digitalerena.com/react-js-topic12/

[^84]: https://www.clariontech.com/blog/reactjs-reusable-components-best-practices-styling-theming

[^85]: https://www.codecademy.com/learn/react-101/modules/react-101-jsx-u/cheatsheet

[^86]: https://www.reddit.com/r/react/comments/1i8pr0z/how_to_set_up_a_fast_development_workflow/

[^87]: https://javascript.plainenglish.io/react-component-building-and-publishing-workflow-c7bb815dd2c

[^88]: https://blog.bitsrc.io/how-to-build-better-react-components-in-2024-2d930b1f30b1

[^89]: https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/React_components

[^90]: https://react.dev/learn/thinking-in-react

[^91]: https://react.dev/learn/writing-markup-with-jsx

[^92]: https://www.dhiwise.com/post/automating-reactjs-development-workflow-for-devs

[^93]: https://velog.io/@dolfalf/React프로젝트-Best-practice-정리

[^94]: https://legacy.reactjs.org/docs/jsx-in-depth.html

