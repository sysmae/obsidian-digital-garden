---
publish: true
---
#2025-08-09 09:53

Tags:

# 절차 지향 프로그래밍 핸드북

## 1. 만들어진 이유: 순서를 정해 혼돈을 잠재우다

컴퓨터 프로그래밍의 초기, 코드는 순서 없이 뒤섞인 스파게티와 같았음. `GOTO` 문을 남발하여 프로그램의 흐름을 파악하기 매우 어려웠고, 코드가 조금만 길어져도 유지보수는 불가능에 가까웠음.

이러한 혼돈 속에서 질서를 찾기 위한 고민의 결과가 바로 **절차 지향 프로그래밍(Procedural Programming)**. 프로그램을 단순히 명령어의 나열이 아닌, **의미 있는 단위의 절차(Procedure)들의 연속**으로 보자는 아이디어에서 출발. 이는 마치 요리법과 같음. 복잡한 요리를 '재료 손질하기', '끓이기', '담아내기' 같은 명확한 단계로 나누면 이해하기 쉽고 따라 하기도 쉬워지는 것과 같은 원리.

## 2. 핵심 구조: 함수와 데이터의 분리

절차 지향 프로그래밍의 세계는 크게 두 가지 요소로 구성됨.

- **절차 (Procedures / Functions)**
    
    - 프로그램의 실질적인 동작을 수행하는 코드 묶음. 한국어로는 주로 **함수(Function)**라고 부름.
        
    - 특정 작업을 수행하도록 설계되며, 필요할 때마다 이름으로 호출하여 재사용 가능.
        
    - 이를 통해 코드의 중복을 피하고 전체 구조를 모듈화하여 관리하기 용이해짐.
        
- **데이터 (Data)**
    
    - 절차(함수)가 처리해야 할 값들.
        
    - 절차 지향에서는 이 데이터가 종종 **전역(Global) 공간**에 놓여 여러 함수가 자유롭게 접근하고 수정할 수 있는 형태로 사용됨.
        
    - 데이터와 데이터를 처리하는 동작(함수)이 명확하게 **분리**되어 있는 것이 가장 큰 특징.
        

이 구조는 '해야 할 일'의 목록을 순서대로 작성하고, 각 일을 처리하는 세부 방법을 별도의 설명서(함수)로 만들어두는 것과 유사함.

## 3. 사용법: 위에서 아래로, 차근차근 해결하기 (Top-Down Design)

절차 지향 프로그래밍은 주로 **하향식 설계(Top-Down Design)** 방식을 따름.

1. **가장 큰 문제 정의**: 프로그램이 최종적으로 해야 할 가장 큰 목표를 정의. (예: "성적 관리 프로그램을 만든다.")
    
2. **문제를 작은 단위로 분해**: 큰 목표를 달성하기 위한 주요 절차들로 나눔. (예: "학생 정보 입력", "과목 점수 입력", "평균 계산", "결과 출력")
    
3. **더 작은 단위로 세분화**: 각 절차를 다시 더 작은, 구체적인 절차로 나눔. (예: "과목 점수 입력" -> "국어 점수 받기", "영어 점수 받기", "입력값 검증하기")
    
4. **함수 구현**: 가장 작은 단위까지 쪼개진 절차들을 실제 코드로 작성. 이것이 바로 함수가 됨.
    

#### C언어 예시: 간단한 계산기

```
#include <stdio.h>

// 전역 변수 (어디서든 접근 가능)
int result;

// 덧셈을 수행하는 절차(함수)
void add(int a, int b) {
    result = a + b;
}

// 뺄셈을 수행하는 절차(함수)
void subtract(int a, int b) {
    result = a - b;
}

// 프로그램의 시작점 (Main Procedure)
int main() {
    int num1 = 20;
    int num2 = 10;

    // 덧셈 절차 호출
    add(num1, num2);
    printf("덧셈 결과: %d\n", result); // 전역 변수 result에 저장된 값을 출력

    // 뺄셈 절차 호출
    subtract(num1, num2);
    printf("뺄셈 결과: %d\n", result); // 전역 변수 result의 값이 변경됨

    return 0;
}
```

위 코드에서 `add`와 `subtract`라는 절차(함수)는 `result`라는 데이터를 공유하며, `main` 함수는 이 절차들을 순서대로 호출하여 프로그램의 흐름을 제어함.

## 4. 심화 탐구: 빛과 그림자

#### 장점 (빛)

- **직관적인 흐름**: 컴퓨터의 실제 처리 방식과 유사하여 코드를 위에서 아래로 읽어나가면 흐름을 이해하기 쉬움.
    
- **높은 실행 속도**: 객체 등을 만드는 추가적인 과정이 없어 상대적으로 빠름. 시스템 프로그래밍이나 임베디드처럼 속도가 중요한 분야에서 여전히 선호됨.
    
- **코드 재사용성**: 함수를 통해 반복되는 코드를 한 곳에서 관리할 수 있음.
    

#### 단점 (그림자)

- **데이터의 불안정성**: **전역 변수**는 절차 지향의 가장 큰 약점. 어떤 함수가 언제 데이터를 바꿨는지 추적하기 어려워, 프로그램이 복잡해지면 "스파게티 코드"보다 더 무서운 **"스파게티 데이터"** 문제를 야기함. 이를 **Side Effect(부작용)**라고도 함.
    
- **유지보수의 어려움**: 데이터 구조가 변경되면 해당 데이터를 사용하는 모든 함수를 찾아 수정해야 함. 하나의 수정이 예상치 못한 다른 부분에 영향을 미칠 가능성이 큼.
    
- **현실 세계와의 괴리**: 현실 세계는 독립적인 '사물(객체)'들의 상호작용으로 이루어지지만, 절차 지향은 '행동'을 중심으로 세상을 바라보기에 복잡한 시스템을 모델링하기 부적합.
    

## 5. 그 이후: 객체 지향에게 자리를 넘겨주다

절차 지향의 '데이터 불안정성'이라는 그림자를 극복하기 위해 등장한 것이 바로 **객체 지향 프로그래밍(Object-Oriented Programming, OOP)**.

OOP는 절차 지향이 분리해두었던 **데이터와 그 데이터를 처리하는 함수를 '객체(Object)'라는 하나의 단위로 묶어버림**. 외부에서는 이 객체가 허용한 방법으로만 데이터에 접근할 수 있게 하여 데이터의 안정성을 획기적으로 높였음.

|구분|**절차 지향 (Procedural)**|**객체 지향 (Object-Oriented)**|
|---|---|---|
|**핵심 단위**|함수 (어떻게 행동할 것인가)|객체 (누가 행동할 것인가)|
|**데이터 처리**|데이터와 함수가 분리됨|데이터와 함수가 캡슐화됨|
|**설계 방식**|Top-Down (하향식)|Bottom-Up (상향식)|
|**주요 언어**|C, Pascal, Fortran|C++, Java, Python, C#|

절차 지향은 현대 프로그래밍의 주류 자리를 객체 지향에 넘겨주었지만, 그 가치가 사라진 것은 아님. 간단한 스크립트나 운영체제 커널, 하드웨어 제어 등 순차적이고 빠른 실행이 중요한 영역에서는 여전히 강력한 힘을 발휘하는 중요한 패러다임.

이 핸드북이 절차 지향 프로그래밍을 이해하는 데 도움이 되었기를 바랍니다. 혹시 객체 지향과의 차이점이나 특정 언어에서의 구현 방식에 대해 더 궁금한 점이 있으신가요?

## References
[[2-✍️ 문헌 노트/절차지향 프로그래밍]]